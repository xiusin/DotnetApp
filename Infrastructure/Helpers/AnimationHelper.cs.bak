using System;
using System.Threading.Tasks;
using Avalonia;
using Avalonia.Animation;
using Avalonia.Animation.Easings;
using Avalonia.Controls;
using Avalonia.Media;
using Avalonia.Styling;
using Avalonia.Threading;

namespace ConfigButtonDisplay.Infrastructure.Helpers;

/// <summary>
/// 动画辅助类，提供常用的动画效果
/// </summary>
public static class AnimationHelper
{
    /// <summary>
    /// 从右侧滑入动画
    /// </summary>
    /// <param name="window">窗口对象</param>
    /// <param name="duration">动画时长（毫秒），默认 300ms</param>
    public static async Task SlideInFromRight(Window window, int duration = 300)
    {
        if (window == null)
        {
            return;
        }

        try
        {
            // 保存目标位置
            var targetPosition = window.Position;
            
            // 设置起始位置（向右偏移 300px）
            var startPosition = new PixelPoint(targetPosition.X + 300, targetPosition.Y);
            window.Position = startPosition;
            
            // 确保窗口可见
            window.Opacity = 0;
            await Task.Delay(10);  // 短暂延迟确保位置已应用
            window.Opacity = 1;
            
            // 执行滑入动画
            var startTime = DateTime.Now;
            var totalDuration = TimeSpan.FromMilliseconds(duration);
            
            while (DateTime.Now - startTime < totalDuration)
            {
                var elapsed = (DateTime.Now - startTime).TotalMilliseconds;
                var progress = Math.Min(1.0, elapsed / duration);
                
                // 使用 ease-out 缓动函数
                var easedProgress = EaseOut(progress);
                
                // 计算当前位置
                var currentX = (int)(startPosition.X + (targetPosition.X - startPosition.X) * easedProgress);
                
                await Dispatcher.UIThread.InvokeAsync(() =>
                {
                    window.Position = new PixelPoint(currentX, targetPosition.Y);
                });
                
                await Task.Delay(16);  // 约 60 FPS
            }
            
            // 确保最终位置准确
            await Dispatcher.UIThread.InvokeAsync(() =>
            {
                window.Position = targetPosition;
            });
            
            Console.WriteLine($"Slide-in animation completed: X={targetPosition.X}, Y={targetPosition.Y}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in slide-in animation: {ex.Message}");
        }
    }
    
    /// <summary>
    /// Ease-out 缓动函数（Cubic）- 更平滑的减速效果
    /// </summary>
    private static double EaseOut(double t)
    {
        return 1 - Math.Pow(1 - t, 3);
    }
    
    /// <summary>
    /// Ease-out 缓动函数（Quart）- 更强的减速效果
    /// </summary>
    private static double EaseOutQuart(double t)
    {
        return 1 - Math.Pow(1 - t, 4);
    }
    
    /// <summary>
    /// Ease-out 缓动函数（Back）- 带回弹效果
    /// </summary>
    private static double EaseOutBack(double t)
    {
        const double c1 = 1.70158;
        const double c3 = c1 + 1;
        return 1 + c3 * Math.Pow(t - 1, 3) + c1 * Math.Pow(t - 1, 2);
    }
    
    /// <summary>
    /// 悬停缩放动画
    /// </summary>
    /// <param name="control">控件对象</param>
    /// <param name="scale">缩放比例，默认 1.02</param>
    /// <param name="duration">动画时长（毫秒），默认 200ms</param>
    public static async Task ScaleOnHover(Control control, double scale = 1.02, int duration = 200)
    {
        if (control == null)
        {
            return;
        }

        try
        {
            var startTime = DateTime.Now;
            var totalDuration = TimeSpan.FromMilliseconds(duration);
            
            while (DateTime.Now - startTime < totalDuration)
            {
                var elapsed = (DateTime.Now - startTime).TotalMilliseconds;
                var progress = Math.Min(1.0, elapsed / duration);
                
                // 使用 ease-in-out 缓动函数
                var easedProgress = EaseInOut(progress);
                
                // 计算当前缩放值
                var currentScale = 1.0 + (scale - 1.0) * easedProgress;
                
                await Dispatcher.UIThread.InvokeAsync(() =>
                {
                    control.RenderTransform = new ScaleTransform(currentScale, currentScale);
                });
                
                await Task.Delay(16);  // 约 60 FPS
            }
            
            // 确保最终缩放值准确
            await Dispatcher.UIThread.InvokeAsync(() =>
            {
                control.RenderTransform = new ScaleTransform(scale, scale);
            });
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in scale animation: {ex.Message}");
        }
    }
    
    /// <summary>
    /// Ease-in-out 缓动函数
    /// </summary>
    private static double EaseInOut(double t)
    {
        return t < 0.5 ? 4 * t * t * t : 1 - Math.Pow(-2 * t + 2, 3) / 2;
    }
    
    /// <summary>
    /// 淡入动画
    /// </summary>
    /// <param name="control">控件对象</param>
    /// <param name="duration">动画时长（毫秒），默认 200ms</param>
    public static async Task FadeIn(Control control, int duration = 200)
    {
        if (control == null)
        {
            return;
        }

        try
        {
            control.Opacity = 0;
            
            var startTime = DateTime.Now;
            var totalDuration = TimeSpan.FromMilliseconds(duration);
            
            while (DateTime.Now - startTime < totalDuration)
            {
                var elapsed = (DateTime.Now - startTime).TotalMilliseconds;
                var progress = Math.Min(1.0, elapsed / duration);
                
                await Dispatcher.UIThread.InvokeAsync(() =>
                {
                    control.Opacity = progress;
                });
                
                await Task.Delay(16);  // 约 60 FPS
            }
            
            // 确保最终透明度为 1
            await Dispatcher.UIThread.InvokeAsync(() =>
            {
                control.Opacity = 1;
            });
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in fade-in animation: {ex.Message}");
        }
    }
    
    /// <summary>
    /// 淡出动画
    /// </summary>
    /// <param name="control">控件对象</param>
    /// <param name="duration">动画时长（毫秒），默认 300ms</param>
    public static async Task FadeOut(Control control, int duration = 300)
    {
        if (control == null)
        {
            return;
        }

        try
        {
            var startOpacity = control.Opacity;
            
            var startTime = DateTime.Now;
            var totalDuration = TimeSpan.FromMilliseconds(duration);
            
            while (DateTime.Now - startTime < totalDuration)
            {
                var elapsed = (DateTime.Now - startTime).TotalMilliseconds;
                var progress = Math.Min(1.0, elapsed / duration);
                
                await Dispatcher.UIThread.InvokeAsync(() =>
                {
                    control.Opacity = startOpacity * (1 - progress);
                });
                
                await Task.Delay(16);  // 约 60 FPS
            }
            
            // 确保最终透明度为 0
            await Dispatcher.UIThread.InvokeAsync(() =>
            {
                control.Opacity = 0;
            });
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in fade-out animation: {ex.Message}");
        }
    }
    
    /// <summary>
    /// NoteTag 从右侧滑入动画
    /// </summary>
    /// <param name="control">控件对象</param>
    /// <param name="duration">动画时长（毫秒），默认 300ms</param>
    public static async Task SlideInFromRightForControl(Control control, int duration = 300)
    {
        if (control == null)
        {
            return;
        }

        try
        {
            // 保存原始位置
            var originalMargin = control.Margin;
            
            // 设置起始位置（向右偏移 100px）
            control.Margin = new Thickness(originalMargin.Left + 100, originalMargin.Top, originalMargin.Right, originalMargin.Bottom);
            control.Opacity = 0;
            
            var startTime = DateTime.Now;
            var totalDuration = TimeSpan.FromMilliseconds(duration);
            
            while (DateTime.Now - startTime < totalDuration)
            {
                var elapsed = (DateTime.Now - startTime).TotalMilliseconds;
                var progress = Math.Min(1.0, elapsed / duration);
                
                // 使用 ease-out 缓动函数
                var easedProgress = EaseOut(progress);
                
                // 计算当前位置和透明度
                var currentOffset = 100 * (1 - easedProgress);
                
                await Dispatcher.UIThread.InvokeAsync(() =>
                {
                    control.Margin = new Thickness(originalMargin.Left + currentOffset, originalMargin.Top, originalMargin.Right, originalMargin.Bottom);
                    control.Opacity = easedProgress;
                });
                
                await Task.Delay(16);  // 约 60 FPS
            }
            
            // 确保最终位置和透明度准确
            await Dispatcher.UIThread.InvokeAsync(() =>
            {
                control.Margin = originalMargin;
                control.Opacity = 1;
            });
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in slide-in animation for control: {ex.Message}");
        }
    }
    
    /// <summary>
    /// NoteTag 向右侧滑出动画
    /// </summary>
    /// <param name="control">控件对象</param>
    /// <param name="duration">动画时长（毫秒），默认 300ms</param>
    public static async Task SlideOutToRight(Control control, int duration = 300)
    {
        if (control == null)
        {
            return;
        }

        try
        {
            var originalMargin = control.Margin;
            
            var startTime = DateTime.Now;
            var totalDuration = TimeSpan.FromMilliseconds(duration);
            
            while (DateTime.Now - startTime < totalDuration)
            {
                var elapsed = (DateTime.Now - startTime).TotalMilliseconds;
                var progress = Math.Min(1.0, elapsed / duration);
                
                // 使用 ease-in 缓动函数
                var easedProgress = progress * progress;
                
                // 计算当前位置和透明度
                var currentOffset = 100 * easedProgress;
                
                await Dispatcher.UIThread.InvokeAsync(() =>
                {
                    control.Margin = new Thickness(originalMargin.Left + currentOffset, originalMargin.Top, originalMargin.Right, originalMargin.Bottom);
                    control.Opacity = 1 - easedProgress;
                });
                
                await Task.Delay(16);  // 约 60 FPS
            }
            
            // 确保最终位置和透明度
            await Dispatcher.UIThread.InvokeAsync(() =>
            {
                control.Margin = new Thickness(originalMargin.Left + 100, originalMargin.Top, originalMargin.Right, originalMargin.Bottom);
                control.Opacity = 0;
            });
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in slide-out animation: {ex.Message}");
        }
    }
    
    /// <summary>
    /// 悬停缩放动画（用于 NoteTag）
    /// </summary>
    /// <param name="control">控件对象</param>
    /// <param name="targetScale">目标缩放比例，默认 1.05</param>
    /// <param name="duration">动画时长（毫秒），默认 200ms</param>
    public static async Task ScaleToTarget(Control control, double targetScale = 1.05, int duration = 200)
    {
        if (control == null)
        {
            return;
        }

        try
        {
            // 获取当前缩放
            var currentTransform = control.RenderTransform as ScaleTransform;
            var startScale = currentTransform?.ScaleX ?? 1.0;
            
            var startTime = DateTime.Now;
            var totalDuration = TimeSpan.FromMilliseconds(duration);
            
            while (DateTime.Now - startTime < totalDuration)
            {
                var elapsed = (DateTime.Now - startTime).TotalMilliseconds;
                var progress = Math.Min(1.0, elapsed / duration);
                
                // 使用 ease-in-out 缓动函数
                var easedProgress = EaseInOut(progress);
                
                // 计算当前缩放值
                var currentScale = startScale + (targetScale - startScale) * easedProgress;
                
                await Dispatcher.UIThread.InvokeAsync(() =>
                {
                    control.RenderTransform = new ScaleTransform(currentScale, currentScale);
                    control.RenderTransformOrigin = new RelativePoint(0.5, 0.5, RelativeUnit.Relative);
                });
                
                await Task.Delay(16);  // 约 60 FPS
            }
            
            // 确保最终缩放值准确
            await Dispatcher.UIThread.InvokeAsync(() =>
            {
                control.RenderTransform = new ScaleTransform(targetScale, targetScale);
                control.RenderTransformOrigin = new RelativePoint(0.5, 0.5, RelativeUnit.Relative);
            });
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in scale animation: {ex.Message}");
        }
    }
    
    /// <summary>
    /// 平滑移动动画（用于标签拖动）
    /// </summary>
    /// <param name="control">控件对象</param>
    /// <param name="targetMargin">目标 Margin</param>
    /// <param name="duration">动画时长（毫秒），默认 200ms</param>
    public static async Task SmoothMove(Control control, Thickness targetMargin, int duration = 200)
    {
        if (control == null)
        {
            return;
        }

        try
        {
            var startMargin = control.Margin;
            
            var startTime = DateTime.Now;
            var totalDuration = TimeSpan.FromMilliseconds(duration);
            
            while (DateTime.Now - startTime < totalDuration)
            {
                var elapsed = (DateTime.Now - startTime).TotalMilliseconds;
                var progress = Math.Min(1.0, elapsed / duration);
                
                // 使用 ease-in-out 缓动函数
                var easedProgress = EaseInOut(progress);
                
                // 计算当前位置
                var currentLeft = startMargin.Left + (targetMargin.Left - startMargin.Left) * easedProgress;
                var currentTop = startMargin.Top + (targetMargin.Top - startMargin.Top) * easedProgress;
                
                await Dispatcher.UIThread.InvokeAsync(() =>
                {
                    control.Margin = new Thickness(currentLeft, currentTop, startMargin.Right, startMargin.Bottom);
                });
                
                await Task.Delay(16);  // 约 60 FPS
            }
            
            // 确保最终位置准确
            await Dispatcher.UIThread.InvokeAsync(() =>
            {
                control.Margin = targetMargin;
            });
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in smooth move animation: {ex.Message}");
        }
    }
}
